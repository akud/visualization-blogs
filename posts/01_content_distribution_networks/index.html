<html>
  <head>
    <title>Content Distribution Networks</title>
    <meta charset="UTF-8">
    <meta name="description" content="visualization of content producer-consumer networks along a spatial axis">
    <meta name="keywords" content="graph theory,networks">
    <meta name="author" content="Alex Kudlick">
    <style>
      .content-wrapper {
        max-width: 1000px;
        margin: 0 auto;
      }
      h1, h2, h3, h4, h5, h6 {
        text-align: center;
      }
    </style>
  </head>
  <body>
    <div class="content-wrapper">
      <h1>Content Distribution Networks</h1>
      <p>
      This post is partially an explanation of an idea around the structure of
      producer-consumer networks on the web, and partially an experiment in
      building the tools to talk about these ideas. The actual content will be
      short, a simple idea, punctuated by a demo.
      </p>
      <p>
      I was talking to a friend the other day about content distribution networks
      online. By this I mean a graph of interactions between people publishing
      content and people consuming content. Examples would be things like
      <em>Facebook</em>, <em>Instagram</em>, and <em>The New York Times</em>.
      These examples differ in the structure of the networks they form - if you
      were to draw a graph, with points for users, points for producers, and a
      line between them to indicate content flowing from one to the other, you
      would find very different graphs.
      </p>

      <p><em>The New York Times</em>, for example, would look like this:</p>


      <div id="nyt-graph"></div>

      <p>
      There is one publisher, the Times, which distributes content to its
      subscribers. The subscribers do not publish content to each other, they
      only consume content from the publisher.
      </p>

      <p> At the other extreme, there's the idealized social network, in which
      everyone talks to everyone else:
      </p>

      <div id="social-media-graph"></div>

      <p>
      These are two extreme examples of graphs that lie along an axis from
      <strong>Many-to-Many</strong> to <strong>One-to-Many</strong> publishing
      relationships. That is, we imagine the graphs exist within a space, and
      we're viewing graphs along a single line, with social media at one end
      and traditional media at the other. As you move along the line, the
      graphs you see vary.

      What do graphs in the middle look like?
      </p>


      <div id="instagram-graph"></div>

      <p>
      Instagram is an example of a network in the middle. There are a few big
      publishers, like celebrities, that publish to a lot of subscribers. There
      is internode chatter amongst the subscribers, and subscribers can follow
      more than one producer.
      </p>

      <p>
      I've been explaining the relationships here with words and pictures, and
      I've sort of sketched out the idea that there's an axis along which all
      these graphs lie. It would be nice if I could show my readers some
      interactive diagram that would let them adjust their position on the axis
      and see the change in graphs that result, so they could get an intuitive feel
      for the concept:
      </p>

      <div id="slider-wrapper" style="width: 100%; margin: 50px auto 100px auto 10px auto; text-align: center;">
        <input id="slider" type="range" min="0" max="100" value="0" defaultValue="0" step="1" style="width: 80%" />
        <div id="slider-graph"></div>
      </div>

      <p>
      These graphs are generated by separating the nodes into two types, <em>producers</em> and <em>consumers</em>,
      requiring that each consumer be connected to at least one producer, and then using three numbers:
      <dl>
        <dt><em>Consumer to Consumer</em></dt>
        <dd>The chance that any given consumer connects with another consumer</dd>
        <dt><em>Consumer to Additional Producer</em></dt>
        <dd>The chance that any given consumer connects with a producer beyond the first</dd>
        <dt><em>Producer to Producer</em></dt>
        <dd>That chance that a producer connects with another producer</dd>
      </dl>

      That parameterizes a three dimensional space. The slider moves you along a line segment in that space
      from <em>(0, 0, 0)</em> to <em>(1,  1, 1)</em>. Here is the space visualized on Wolfram Alpha:
      </p>

      <p>
      <a href="https://www.wolframalpha.com/input/?i=line+segment+from+(0,0,0)+to+(1,1,1)"><img src="3dbox.gif" /></a>
      </p>

      <!--<p>-->
        <!--<label>-->
          <!--Consumer To Consumer: <span id="slider1-value">1.0</span>-->
          <!--<input id="slider1" type="range" min="0" max="100" value="0" step="1" />-->
        <!--</label>-->
      <!--</p>-->

      <!--<p>-->
        <!--<label>-->
          <!--Consumer To Additional Producer: <span id="slider2-value">1.0</span>-->
          <!--<input id="slider2" type="range" min="0" max="100" value="0" step="1" />-->
        <!--</label>-->

      <!--</p>-->
      <!--<p>-->
        <!--<label>-->
          <!--Producer to Producer: <span id="slider3-value">1.0</span>-->
          <!--<input id="slider3" type="range" min="0" max="100" value="0" step="1" />-->
        <!--</label>-->
      <!--</p>-->


      <footer>
        <p>Posted by: Alex Kudlick</p>
        <p>
        If you're interested in the content here, and would like to engage more, you
        can follow me on <a href="https://plus.google.com/+AlexKudlick">Google+</a>. You may
        also be interested in my <a href="https://wwtawwtac.libsyn.com/">my podcast about code.</a>
        </p>
        <p>Powered by <a href="https://github.com/mauriciopoppe/greuler">greuler</a></p>
        <p><a href="../../index.html">back</a></p>
      </footer>
    </div>
    <script src="../../vendor/d3.min.js"></script>
    <script src="../../vendor/cola.v3.min.js"></script>
    <script src="../../vendor/greuler.min.js"></script>
    <!--<script src="../vendor/greuler.js"></script>-->
    <script type="text/javascript">
      greuler({
        target: '#nyt-graph',
        data: {
          nodes: [
            {id: 0, label: 'pub', r: 20},
            {id: 1, label: 'sub', r: 20},
            {id: 2, label: 'sub', r: 20},
            {id: 3, label: 'sub', r: 20},
            {id: 4, label: 'sub', r: 20}
          ],
          links: [
            {source: 0, target: 1},
            {source: 0, target: 2},
            {source: 0, target: 3},
            {source: 0, target: 4},
          ],
          constraints: [
            {
              type: 'alignment',
              axis: 'x',
              offsets: [
                {node:1, offset: 0},
                {node:2, offset: 0},
                {node:3, offset: 0},
                {node:4, offset: 0},
              ]
            },
            { axis:"x", left:1, right:0, gap:100}
          ]
        }
      }).update();
      greuler({
        target: '#social-media-graph',
        height: 200,
        data: {
          nodes: [
            {id: 0, label: ''},
            {id: 1, label: ''},
            {id: 2, label: ''},
            {id: 3, label: ''},
            {id: 4, label: ''},
            {id: 5, label: ''},
          ],
          links: [
            {source: 0, target: 1},
            {source: 0, target: 2},
            {source: 0, target: 3},
            {source: 0, target: 4},
            {source: 0, target: 5},

            {source: 1, target: 2},
            {source: 1, target: 3},
            {source: 1, target: 4},
            {source: 1, target: 5},

            {source: 2, target: 3},
            {source: 2, target: 4},
            {source: 2, target: 5},

            {source: 3, target: 4},
            {source: 3, target: 5},

            {source: 4, target: 5},
          ],
        }
      }).update();
      greuler({
        target: '#instagram-graph',
        height: 600,
        data: {
          nodes: [
            {id: 0, label: 'celeb', r: 20},
            {id: 1, label: ''},
            {id: 2, label: ''},
            {id: 3, label: ''},
            {id: 4, label: 'celeb', r: 20},
            {id: 5, label: ''},
            {id: 6, label: ''},
          ],
          links: [
            {source: 0, target: 1},
            {source: 0, target: 2},
            {source: 0, target: 3},

            {source: 1, target: 2},
            {source: 1, target: 3},
            {source: 2, target: 3},

            {source: 4, target: 5},
            {source: 4, target: 6},
            {source: 5, target: 6},
            {source: 5, target: 3},
          ],
          constraints: [
            {axis:"x", left:1, right:0, gap:100},
            {axis:"x", left:2, right:0, gap:100},
            {axis:"x", left:3, right:0, gap:100},
            {axis:"x", left:5, right:0, gap:100},
            {axis:"x", left:6, right:0, gap:100},

            {axis:"x", left:1, right:3, gap:30},

            {axis:"x", left:1, right:4, gap:100},
            {axis:"x", left:2, right:4, gap:100},
            {axis:"x", left:3, right:4, gap:100},
            {axis:"x", left:5, right:4, gap:100},
            {axis:"x", left:6, right:4, gap:100},
          ]
        }
      }).update();

    function chooseRandom(arr) {
      return arr[Math.floor(Math.random()*arr.length)];
    }

    function Node(id) {
      this.id = id;
      this.connectedConsumers = [];
      this.connectedProducers = [];
    }

    Node.prototype._getReverseConnections = function(otherNode) { throw new Error('used raw node ' + this.id); };
    Node.prototype.getGreulerNode = function() { throw new Error('used raw node ' + this.id); };

    Node.prototype.addProducerConnection = function(otherNode) {
      //console.log('connecting ' + this.id + ' to producer ' + otherNode.id);
      this.connectedProducers.push(otherNode);
      this._getReverseConnections(otherNode).push(this);
      return { source: this.id, target: otherNode.id, id: this.makeEdgeId(otherNode) };
    };

    Node.prototype.addConsumerConnection = function(otherNode) {
      //console.log('connecting ' + this.id + ' to consumer ' + otherNode.id);
      this.connectedConsumers.push(otherNode);
      this._getReverseConnections(otherNode).push(this);
      return { source: this.id, target: otherNode.id, id: this.makeEdgeId(otherNode) };
    };

    Node.prototype.removeProducerConnection = function(otherNode) {
      //console.log('disconnecting ' + this.id + ' from producer ' + otherNode.id);
      this.connectedProducers.splice(this.connectedProducers.indexOf(otherNode), 1);
      var reverseConnections = this._getReverseConnections(otherNode);
      reverseConnections.splice(reverseConnections.indexOf(this), 1);
      return { id: this.makeEdgeId(otherNode) };
    };

    Node.prototype.removeConsumerConnection = function(otherNode) {
      //console.log('disconnecting ' + this.id + ' from producer ' + otherNode.id);
      this.connectedConsumers.splice(this.connectedConsumers.indexOf(otherNode), 1);
      var reverseConnections = this._getReverseConnections(otherNode);
      reverseConnections.splice(reverseConnections.indexOf(this), 1);
      return { id: this.makeEdgeId(otherNode) };
    };

    Node.prototype.getConnectedConsumers = function() {
      return this.connectedConsumers;
    };

    Node.prototype.getConnectedProducers = function() {
      return this.connectedProducers;
    };

    Node.prototype.getNumConsumerConnections = function() {
      return this.connectedConsumers.length;
    };

    Node.prototype.getNumProducerConnections = function() {
      return this.connectedProducers.length;
    };

    Node.prototype.isConnectedToConsumer = function(otherNode) {
      return this.connectedConsumers.indexOf(otherNode) !== -1;
    };

    Node.prototype.isConnectedToProducer = function(otherNode) {
      return this.connectedProducers.indexOf(otherNode) !== -1;
    };

    Node.prototype.makeEdgeId = function(otherNode) {
      if (this.id < otherNode.id) {
        return this.id + '-' + otherNode.id;
      } else {
        return otherNode.id + '-' + this.id;
      }
    };

    function ProducerNode(id) {
      Node.call(this, id);
    }
    ProducerNode.prototype = new Node();
    ProducerNode.prototype._getReverseConnections = function(otherNode) {
      return otherNode.connectedProducers;
    };
    ProducerNode.prototype.getGreulerNode = function() {
      return { id: this.id, label: '', fill: '#12b7a6' };
    };

    function ConsumerNode(id) {
      Node.call(this, id);
    }
    ConsumerNode.prototype = new Node();
    ConsumerNode.prototype._getReverseConnections = function(otherNode) {
      return otherNode.connectedConsumers;
    };
    ConsumerNode.prototype.getGreulerNode = function() {
      return { id: this.id, label: '' };
    };

    function NetworkGraph(opts) {
      opts = Object.assign({
        numNodes: 20,
        percentProducers: 0.2,
        consumerToConsumer: 0.0,
        consumerToAdditionalProducer: 0.0,
        producerToProducer: 0.0,
        smallGap: 20,
        largeGap: 100,
        target: '',
        width: 700,
        height: 700,
      }, opts)
      var numNodes = opts.numNodes;
      var numProducers = Math.floor(opts.percentProducers * numNodes);

      this.consumerToConsumer =  opts.consumerToConsumer;
      this.consumerToAdditionalProducer = opts.consumerToAdditionalProducer;
      this.producerToProducer = opts.producerToProducer;


      this.producers = [];
      this.consumers = [];

      var nodes = [];
      var constraints = [];
      var links = [];

      for (var i = 0; i < numProducers; i++) {
        var producer = new ProducerNode(i);
        this.producers.push(producer);
        nodes.push(producer.getGreulerNode());
        for (var j = 0; j < numProducers; j++) {
          if (j !== i) {
            constraints.push({ axis: 'y', left: i, right: j, gap: opts.smallGap });
          }
        }
      }
      for (var i = numProducers; i < numNodes; i++) {
        var consumer = new ConsumerNode(i);
        this.consumers.push(consumer);
        nodes.push(consumer.getGreulerNode());
        links.push(consumer.addProducerConnection(chooseRandom(this.producers)));
        this.producers.forEach(function(producer) {
            constraints.push({
              axis: 'x',
              left: i,
              right: producer.id,
              gap: opts.largeGap
            });
        });
      }

      this.instance = greuler({
        target: opts.target,
        width: opts.width,
        height: opts.height,
        data: {
          nodes: nodes,
          links: links,
          constraints: constraints,
          linkDistance: function(d) { return d.linkDistance || 160; },
        },
      }).update();
      this.update();
    }

    NetworkGraph.prototype.update = function(opts) {
      opts = Object.assign({
        consumerToConsumer: this.consumerToConsumer,
        consumerToAdditionalProducer: this.consumerToAdditionalProducer,
        producerToProducer: this.producerToProducer,
      }, opts);

      this.consumers.forEach(function(c1) {
        if (opts.consumerToConsumer < this.consumerToConsumer) {
          this.decrementConsumerToConsumerConnections(c1, opts.consumerToConsumer);
        } else{
          this.incrementConsumerToConsumerConnections(c1, opts.consumerToConsumer);
        }

        if (opts.consumerToAdditionalProducer < this.consumerToAdditionalProducer) {
          this.decrementConsumerToAdditionalProducerConnections(c1, opts.consumerToAdditionalProducer);
        } else{
          this.incrementConsumerToAdditionalProducerConnections(c1, opts.consumerToAdditionalProducer);
        }
      }, this);

      this.producers.forEach(function(p) {
        if (opts.producerToProducer < this.producerToProducer) {
          this.decrementProducerToProducerConnections(p, opts.producerToProducer);
        } else{
          this.incrementProducerToProducerConnections(p, opts.producerToProducer);
        }
      }, this);

      this.consumerToConsumer = opts.consumerToConsumer;
      this.consumerToAdditionalProducer = opts.consumerToAdditionalProducer;
      this.producerToProducer = opts.producerToProducer;
      this.instance.update();
    };

    NetworkGraph.prototype.decrementConsumerToConsumerConnections = function(source, targetPercent) {
      //console.log('decrementing to ' + targetPercent + ' chance of connection consumer to consumer');
      var targetNumConnections = Math.floor((this.consumers.length - 1) * targetPercent);
      var numExistingConnections = source.getNumConsumerConnections();
      if (numExistingConnections > targetNumConnections) {
        var numToRemove = numExistingConnections - targetNumConnections;
        var chanceToRemove = numToRemove / numExistingConnections;
        //console.log('modified ' + targetPercent + ' to ' + chanceToRemove + ' for ' + source.id);
        source.getConnectedConsumers().forEach(function(c2) {
          if (Math.random() <= chanceToRemove) {
            this.instance.graph.removeEdge(source.removeConsumerConnection(c2));
          }
        }, this);
      }
    };

    NetworkGraph.prototype.decrementConsumerToAdditionalProducerConnections = function(source, targetPercent) {
      //console.log('decrementing to ' + targetPercent + ' chance of connection consumer to additional producer');
      var targetNumConnections = Math.floor((this.producers.length - 1) * targetPercent);
      var numExistingConnections = source.getNumProducerConnections() - 1;
      if (numExistingConnections > targetNumConnections) {
        var numToRemove = numExistingConnections - targetNumConnections;
        var chanceToRemove = numToRemove / numExistingConnections;
        //console.log('modified ' + targetPercent + ' to ' + chanceToRemove + ' for ' + source.id);
        source.getConnectedProducers().forEach(function(p) {
            if (source.getNumProducerConnections() > 1 && Math.random() <= chanceToRemove) {
            this.instance.graph.removeEdge(source.removeProducerConnection(p));
          }
        }, this);
      }
    };

     NetworkGraph.prototype.decrementProducerToProducerConnections = function(source, targetPercent) {
      //console.log('decrementing to ' + targetPercent + ' chance of connection producer to producer');
      var targetNumConnections = Math.floor((this.producers.length - 1) * targetPercent);
      var numExistingConnections = source.getNumProducerConnections();
      if (numExistingConnections > targetNumConnections) {
        var numToRemove = numExistingConnections - targetNumConnections;
        var chanceToRemove = numToRemove / numExistingConnections;
        //console.log('modified ' + targetPercent + ' to ' + chanceToRemove + ' for ' + source.id);
        source.getConnectedProducers().forEach(function(p) {
          if (Math.random() <= chanceToRemove) {
            this.instance.graph.removeEdge(source.removeProducerConnection(p));
          }
        }, this);
      }
    };

    NetworkGraph.prototype.incrementConsumerToConsumerConnections = function(source, targetPercent) {
      //console.log('incrementing to ' + targetPercent + ' chance of connection consumer to consumer');
      var targetNumConnections = Math.floor((this.consumers.length - 1) * targetPercent);
      var numExistingConnections = source.getNumConsumerConnections();
      if (numExistingConnections < targetNumConnections) {
        var numToAdd = targetNumConnections - numExistingConnections;
        var chanceToAdd = numToAdd / (this.consumers.length - 1 - numExistingConnections);
        //console.log('modified ' + targetPercent + ' to ' + chanceToAdd + ' for ' + source.id);
        this.consumers.forEach(function(c2) {
            if (c2 !== source &&
              !source.isConnectedToConsumer(c2) &&
              Math.random() <= chanceToAdd) {
            this.instance.graph.addEdge(source.addConsumerConnection(c2));
          }
        }, this);
      }
    };

    NetworkGraph.prototype.incrementConsumerToAdditionalProducerConnections = function(source, targetPercent) {
      //console.log('incrementing to ' + targetPercent + ' chance of connection consumer to additional producer');
      var targetNumConnections = Math.floor((this.producers.length - 1) * targetPercent);
      var numExistingConnections = source.getNumProducerConnections();
      if (numExistingConnections < targetNumConnections) {
        var numToAdd = targetNumConnections - numExistingConnections;
        var chanceToAdd = numToAdd / (this.producers.length - 1 - numExistingConnections);
        //console.log('modified ' + targetPercent + ' to ' + chanceToAdd + ' for ' + source.id);
        this.producers.forEach(function(p) {
            if (!source.isConnectedToProducer(p) && Math.random() <= chanceToAdd) {
            this.instance.graph.addEdge(source.addProducerConnection(p));
          }
        }, this);
      }
    };

    NetworkGraph.prototype.incrementProducerToProducerConnections = function(source, targetPercent) {
      //console.log('incrementing to ' + targetPercent + ' chance of connection producer to producer');
      var targetNumConnections = Math.floor((this.producers.length - 1) * targetPercent);
      var numExistingConnections = source.getNumProducerConnections();
      if (numExistingConnections < targetNumConnections) {
        var numToAdd = targetNumConnections - numExistingConnections;
        var chanceToAdd = numToAdd / (this.producers.length - 1 - numExistingConnections);
        //console.log('modified ' + targetPercent + ' to ' + chanceToAdd + ' for ' + source.id);
        this.producers.forEach(function(p) {
            if (source !== p && !source.isConnectedToProducer(p) && Math.random() <= chanceToAdd) {
            this.instance.graph.addEdge(source.addProducerConnection(p));
          }
        }, this);
      }
    };

    function plus(p1, p2) {
      return {
        consumerToConsumer: p1.consumerToConsumer + p2.consumerToConsumer,
        consumerToAdditionalProducer: p1.consumerToAdditionalProducer + p2.consumerToAdditionalProducer,
        producerToProducer: p1.producerToProducer + p2.producerToProducer,
      }
    }

    function minus(p1, p2) {
      return {
        consumerToConsumer: p1.consumerToConsumer - p2.consumerToConsumer,
        consumerToAdditionalProducer: p1.consumerToAdditionalProducer - p2.consumerToAdditionalProducer,
        producerToProducer: p1.producerToProducer - p2.producerToProducer,
      }
    }

    function times(p1, scalar) {
      return {
        consumerToConsumer: p1.consumerToConsumer * scalar,
        consumerToAdditionalProducer: p1.consumerToAdditionalProducer * scalar,
        producerToProducer: p1.producerToProducer * scalar,
      }
    }

    function Segment(opts) {
      this.distanceSoFar = opts.distanceSoFar;
      this.length = opts.length;
      this.leftPoint = opts.leftPoint;
      this.rightPoint = opts.rightPoint;
      this.differenceVector = minus(this.rightPoint, this.leftPoint);
    }

    Segment.prototype.normalizeTo = function(totalDistance) {
      this.startingPercent = this.distanceSoFar / totalDistance;
      this.endingPercent = (this.distanceSoFar + this.length) / totalDistance;
      console.log(
          '(' + this.distanceSoFar + ' + ' + this.length + ') / ' + totalDistance +
          ' -> [' + this.startingPercent + ',' + this.endingPercent + ')'
      );
    }

    Segment.prototype.accepts = function(value) {
      return value >= this.startingPercent && value < this.endingPercent;
    }

    Segment.prototype.splay = function(value) {
      var percentOfThisSegment = (this.endingPercent - value) / (this.endingPercent - this.startingPercent);
      //console.log(
      //  '(' + this.endingPercent + ' - ' + value + ')' +
      //  ' / ' +
      //  '(' + this.endingPercent + ' - ' + this.startingPercent + ')' +
      //  ' = ' + percentOfThisSegment
      //);
      var splayed = plus(this.leftPoint, times(this.differenceVector, percentOfThisSegment));
      //console.log(splayed);
      return splayed;
    }

    function Slider(opts) {
      opts = Object.assign({
        graph: null,
        target: null,
        points: [
          { consumerToConsumer: 0.0, consumerToAdditionalProducer: 0.0, producerToProducer: 0.0},
          { consumerToConsumer: 1.0, consumerToAdditionalProducer: 1.0, producerToProducer: 1.0},
        ],
      }, opts);
      this.graph = opts.graph;
      this.segments = [];
      var totalDistance = 0;
      var leftPoint = opts.points[0];
      for (var i = 1; i < opts.points.length; i++) {
        var rightPoint = opts.points[i];
        var length =
          Math.pow(leftPoint.consumerToConsumer - rightPoint.consumerToConsumer, 2) +
          Math.pow(leftPoint.consumerToAdditionalProducer - rightPoint.consumerToAdditionalProducer, 2) +
          Math.pow(leftPoint.producerToProducer - rightPoint.producerToProducer, 2);
        this.segments.push(new Segment({
          distanceSoFar: totalDistance,
          length: length,
          leftPoint: leftPoint,
          rightPoint: rightPoint,
        }));
        leftPoint = rightPoint;
        totalDistance += length;
      }
      this.segments.forEach(function(segment) { segment.normalizeTo(totalDistance); });

      document.querySelector(opts.target).addEventListener('change', function(e) {
        var value = (parseInt(e.target.value)) / 100;
        //console.log('onchange start ' + value);
        this.update(value);
        //console.log('onchange finish ' + value);
      }.bind(this)
      );
    }

    Slider.prototype.update = function(value) {
      var segment = this.segments.find(function(s) { return s.accepts(value); }) || this.segments[this.segments.length - 1];
      this.graph.update(segment.splay(value));
    }

    var graph = new NetworkGraph({
      target: '#slider-graph',
      consumerToConsumer: 1.0,
      consumerToAdditionalProducer: 1.0,
      producerToProducer: 1.0,
      numNodes: 15,
    });
    var slider = new Slider({
      target: '#slider',
      graph: graph,
      //points: [
      //    { consumerToConsumer: 0.0, consumerToAdditionalProducer: 0.0, producerToProducer: 0.0},
      //    { consumerToConsumer: 0.3, consumerToAdditionalProducer: 0.1, producerToProducer: 0.0},
      //    { consumerToConsumer: 0.5, consumerToAdditionalProducer: 0.3, producerToProducer: 0.0},
      //    { consumerToConsumer: 0.7, consumerToAdditionalProducer: 0.5, producerToProducer: 0.5},
      //    { consumerToConsumer: 0.9, consumerToAdditionalProducer: 0.7, producerToProducer: 0.75},
      //    { consumerToConsumer: 1.0, consumerToAdditionalProducer: 1.0, producerToProducer: 1.0},
      //],
    });
    </script>
  </body>
</html>
